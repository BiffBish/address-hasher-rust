use colored::Colorize;
use std::hint::black_box;

use crate::hmac32::Hmac;
use crate::{
    profile, Profile, IS_PROFILE_RECONCILING, IS_PROFILING, PROFILING_DEPTH, PROFILING_MAP,
    PROFILING_PATH,
};

#[profile()]
pub fn pbkdf2_32(password: Vec<u32>, salt: Vec<u32>, count: u32, length: usize) -> Vec<u32> {
    let mut prf = Hmac::new(password);
    let mut u: Vec<u32>;
    let mut ui: Vec<u32>;
    let mut k: u32 = 1;
    let mut out: Vec<u32> = vec![];
    while 32 * out.len() < length {
        let thing: Vec<u32> = vec![salt.clone(), vec![k]].into_iter().flatten().collect();
        ui = prf._encrypt(&thing);
        u = ui.clone();
        for _ in 1..count {
            ui = prf._encrypt(&ui);
            for j in 0..ui.len() {
                u[j] ^= ui[j];
            }
        }

        out.append(&mut u);

        k += 1;
    }
    out
}

// #[cfg(test)]
// mod tests {

//     use super::*;

//     #[test]
//     fn pbkdf2_matches() {
//         time_it!("pbkdf2" ,
//             let res = pbkdf2(
//                 vec![
//                     0x73, 0x75, 0x72, 0x72, 0x6f, 0x75, 0x6e, 0x64, 0x20, 0x6d, 0x69, 0x73, 0x73, 0x20,
//                     0x6e, 0x6f, 0x6d, 0x69, 0x6e, 0x65, 0x65, 0x20, 0x64, 0x72, 0x65, 0x61, 0x6d, 0x20,
//                     0x67, 0x61, 0x70, 0x20, 0x63, 0x72, 0x6f, 0x73, 0x73, 0x20, 0x61, 0x73, 0x73, 0x61,
//                     0x75, 0x6c, 0x74, 0x20, 0x74, 0x68, 0x61, 0x6e, 0x6b, 0x20, 0x63, 0x61, 0x70, 0x74,
//                     0x61, 0x69, 0x6e, 0x20, 0x70, 0x72, 0x6f, 0x73, 0x70, 0x65, 0x72, 0x20, 0x64, 0x72,
//                     0x6f, 0x70, 0x20, 0x64, 0x75, 0x74, 0x79, 0x20, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x20,
//                     0x63, 0x61, 0x6e, 0x64, 0x79, 0x20, 0x77, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x20, 0x77,
//                     0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x20, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x20, 0x70,
//                     0x75, 0x74,
//                 ],
//                 vec![0x6d, 0x6e, 0x65, 0x6d, 0x6f, 0x6e, 0x69, 0x63],
//                 2048,
//                 512,
//             );
//             // }
//             assert_eq!(
//                 res,
//                 vec![
//                     0x7e, 0xac, 0xf8, 0xe4, 0x21, 0xfd, 0x62, 0x6e, 0xa6, 0x65, 0x31, 0x75, 0x5f, 0xb7,
//                     0xeb, 0xe2, 0x3a, 0xd7, 0xd1, 0x54, 0xe8, 0x4a, 0xb1, 0x35, 0xf7, 0xa0, 0x08, 0xff,
//                     0x7c, 0xcf, 0x86, 0x7f, 0x4c, 0x78, 0x24, 0x3d, 0x2b, 0xa6, 0x45, 0x4e, 0xe3, 0x6a,
//                     0x89, 0xa1, 0x08, 0x72, 0xd4, 0x2d, 0x96, 0x39, 0x86, 0x3f, 0x88, 0x4a, 0xef, 0x69,
//                     0x25, 0xb8, 0x21, 0x7e, 0xc9, 0x0f, 0x6f, 0x30
//                 ]
//             )
//         );
//     }
// }
